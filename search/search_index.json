{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"slothy","text":"<p>Super-easy lazy importing in Python.</p> <p>Intended to be used as a guard for expensive or type-checking imports.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>&gt;&gt;&gt; from slothy import lazy_importing\n&gt;&gt;&gt; \n&gt;&gt;&gt; with lazy_importing():\n...     from asyncio import get_event_loop, run, erroneous_import\n...     print(get_event_loop)\n...     print(run)\n...     print(erroneous_import)\n... \n&lt;from asyncio import get_event_loop, ... (\"&lt;stdin&gt;\", line 2)&gt;\n&lt;from asyncio import ..., run, ... (\"&lt;stdin&gt;\", line 2)&gt;\n&lt;from asyncio import ..., erroneous_import (\"&lt;stdin&gt;\", line 2)&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; get_event_loop\n&lt;built-in function get_event_loop&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; globals()[\"run\"]\n&lt;function run at 0xdead1337beef&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; erroneous_import\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"./slothy/_importing.py\", line 423, in __eq__\n    self._import(their_import)\n  File \"./slothy/_importing.py\", line 304, in __import\n    raise exc from None\n  File \"./slothy/_importing.py\", line 286, in __import\n    obj = _import_item_from_list(\n  File \"./slothy/_importing.py\", line 203, in _import_item_from_list\n    raise ImportError(msg) from None\nImportError: cannot import name 'erroneous_import' from 'asyncio'\n(caused by delayed execution of \"&lt;stdin&gt;\", line 2)\n</code></pre> <p>By default, <code>with lazy_importing()</code> statements fail immediately on unsupported Python implementations, i.e. those that don't define <code>sys._getframe</code>. To disable this behavior, which might be particularly useful in libraries, use <code>with lazy_importing(prevent_eager=False)</code>.</p>"},{"location":"#credits","title":"Credits","text":"<p>Many thanks to Jelle Zijlstra @JelleZijlstra who wrote a basic dict key lookup-based lazy importing implementation that is now the core solution of slothy.</p> <p>Kudos to Carl Meyer @carljm who willingly sacrificed his time to consult the project with me and share his deep knowledge of the problem at the bigger picture. His experience with PEP 690 as a Meta software engineer significantly helped me.</p> <p>I'm very grateful to Jim Fulton @jimfulton for making the library possible in the first place almost 30 years ago.</p> <p>Special thanks to Alex Waygood @AlexWaygood who made this project possible by sharing his knowledge of CPython implementation details regarding name lookup behavior.</p> <p>Shoutout to Will McGugan @willmcgugan who supported the idea of slothy from the very beginning and promoted the project on Twitter.</p>"},{"location":"#installation","title":"Installation","text":"<p>You might simply install slothy it with pip (or any other PyPI package installer of choice):</p> <pre><code>pip install slothy\n</code></pre>"},{"location":"#for-contributors","title":"For Contributors","text":"<p>Note</p> <p>If you use Windows, it is highly recommended to complete the installation in the way presented below through WSL2.</p> <ol> <li> <p>Fork the slothy repository on GitHub.</p> </li> <li> <p>Install Poetry.     Poetry is an amazing tool for managing dependencies &amp; virtual environments, building packages and publishing them.     You might use pipx to install it globally (recommended):</p> <pre><code>pipx install poetry\n</code></pre> <p><sub>If you encounter any problems, refer to the official documentation for the most up-to-date installation instructions.</sub></p> <p>Be sure to have Python 3.8 installed\u2014if you use Rye, simply run:</p> <pre><code>rye toolchain fetch 3.8\n</code></pre> </li> <li> <p>Clone your fork locally and install dependencies.</p> <pre><code>git clone https://github.com/your-username/slothy path/to/slothy\ncd path/to/slothy\npoetry env use $(cat .python-version)\npoetry install\n</code></pre> <p>Next up, simply activate the virtual environment and install pre-commit hooks:</p> <pre><code>poetry shell\npre-commit install\n</code></pre> </li> </ol> <p>For more information on how to contribute, check out CONTRIBUTING.md. Always happy to accept contributions! \u2764\ufe0f</p>"},{"location":"#legal-info","title":"Legal Info","text":"<p>\u00a9 Copyright by Bartosz S\u0142awecki (@bswck). This software is licensed under the terms of MIT License.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#slothy.SLOTHY_ENABLED","title":"<code>SLOTHY_ENABLED: bool = not getenv('SLOTHY_DISABLE')</code>","text":"<p>Whether slothy is enabled.</p>"},{"location":"api/#slothy._importing.lazy_importing","title":"<code>lazy_importing(*, prevent_eager=True, stack_offset=1, _fallback=FALLBACK_MISSING)</code>","text":"<p>Use slothy imports in a <code>with</code> statement.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[None]</code>           \u2013            <p>Context manager's underlying generator.</p> </li> </ul> Source code in <code>slothy/_importing.py</code> <pre><code>@contextmanager\ndef lazy_importing(\n    *,\n    prevent_eager: bool = True,  # noqa: ARG001\n    stack_offset: int = 1,\n    _fallback: object = FALLBACK_MISSING,\n) -&gt; Iterator[None]:\n    \"\"\"\n    Use slothy imports in a `with` statement.\n\n    Parameters\n    ----------\n    prevent_eager\n        If True, will raise a `RuntimeError` if slothy cannot guarantee\n        to not fall back to eager imports on unsupported Python implementation.\n        On supported Python implementations this parameter doesn't change the behavior.\n        A general recommendation is to set this to `True` in applications\n        and `False` in libraries.\n    stack_offset\n        The stack offset to use.\n\n    Returns\n    -------\n    Iterator[None]\n        Context manager's underlying generator.\n\n    \"\"\"\n    frame = get_frame(stack_offset + 1)  # +1 from @contextmanager\n    builtin_import = _get_builtin_import(frame.f_builtins)\n\n    import_wrapper = partial(\n        _slothy_import_locally,\n        _target=frame.f_globals[\"__name__\"],\n        _builtin_import=builtin_import,\n    )\n    import_wrapper.__slothy__ = True  # type: ignore[attr-defined]\n\n    frame.f_builtins[\"__import__\"] = import_wrapper\n    try:\n        yield\n    finally:\n        _process_slothy_objects(frame.f_locals, fallback=_fallback)\n        frame.f_builtins[\"__import__\"] = builtin_import\n</code></pre>"},{"location":"api/#slothy._importing.lazy_importing(prevent_eager)","title":"<code>prevent_eager</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will raise a <code>RuntimeError</code> if slothy cannot guarantee to not fall back to eager imports on unsupported Python implementation. On supported Python implementations this parameter doesn't change the behavior. A general recommendation is to set this to <code>True</code> in applications and <code>False</code> in libraries.</p>"},{"location":"api/#slothy._importing.lazy_importing(stack_offset)","title":"<code>stack_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The stack offset to use.</p>"},{"location":"api/#slothy._importing.lazy_importing_if","title":"<code>lazy_importing_if(condition, *, prevent_eager=True, stack_offset=1)</code>","text":"<p>Use slothy imports only if condition evaluates to truth.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AbstractContextManager[None]</code>           \u2013            <p>The context manager.</p> </li> </ul> Source code in <code>slothy/_importing.py</code> <pre><code>def lazy_importing_if(\n    condition: object,\n    *,\n    prevent_eager: bool = True,\n    stack_offset: int = 1,\n) -&gt; AbstractContextManager[None]:\n    \"\"\"\n    Use slothy imports only if condition evaluates to truth.\n\n    Parameters\n    ----------\n    condition\n        The condition to evaluate.\n    prevent_eager\n        If True, will raise a `RuntimeError` if slothy cannot guarantee\n        to not fall back to eager imports on unsupported Python implementation.\n        On supported Python implementations this parameter doesn't change the behavior.\n        A general recommendation is to set this to `True` in applications\n        and `False` in libraries.\n    stack_offset\n        The stack offset to use.\n\n    Returns\n    -------\n    AbstractContextManager[None]\n        The context manager.\n\n    \"\"\"\n    return (\n        lazy_importing(prevent_eager=prevent_eager, stack_offset=stack_offset)\n        if condition\n        else nullcontext()\n    )\n</code></pre>"},{"location":"api/#slothy._importing.lazy_importing_if(condition)","title":"<code>condition</code>","text":"(<code>object</code>)           \u2013            <p>The condition to evaluate.</p>"},{"location":"api/#slothy._importing.lazy_importing_if(prevent_eager)","title":"<code>prevent_eager</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will raise a <code>RuntimeError</code> if slothy cannot guarantee to not fall back to eager imports on unsupported Python implementation. On supported Python implementations this parameter doesn't change the behavior. A general recommendation is to set this to <code>True</code> in applications and <code>False</code> in libraries.</p>"},{"location":"api/#slothy._importing.lazy_importing_if(stack_offset)","title":"<code>stack_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The stack offset to use.</p>"},{"location":"api/#slothy._importing.type_importing","title":"<code>type_importing(*, default_type=Any, stack_offset=1)</code>","text":"<p>Use this to import symbols recognized by type checkers that do not exist at runtime.</p> <p>This function should generally be considered a runtime-friendly alternative to using <code>if typing.TYPE_CHECKING</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AbstractContextManager[None]</code>           \u2013            <p>The context manager.</p> </li> </ul> Source code in <code>slothy/_importing.py</code> <pre><code>def type_importing(\n    *,\n    default_type: object = Any,\n    stack_offset: int = 1,\n) -&gt; AbstractContextManager[None]:\n    \"\"\"\n    Use this to import symbols recognized by type checkers that do not exist at runtime.\n\n    This function should generally be considered a runtime-friendly alternative to\n    using `if typing.TYPE_CHECKING`.\n\n    Parameters\n    ----------\n    default_type\n        The item to import in case of a failure. Defaults to [`typing.Any`][]\n    stack_offset\n        The stack offset to use.\n\n    Returns\n    -------\n    AbstractContextManager[None]\n        The context manager.\n\n    \"\"\"\n    return lazy_importing(\n        prevent_eager=True,\n        stack_offset=stack_offset,\n        _fallback=default_type,\n    )\n</code></pre>"},{"location":"api/#slothy._importing.type_importing(default_type)","title":"<code>default_type</code>","text":"(<code>object</code>, default:                   <code>Any</code> )           \u2013            <p>The item to import in case of a failure. Defaults to <code>typing.Any</code></p>"},{"location":"api/#slothy._importing.type_importing(stack_offset)","title":"<code>stack_offset</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The stack offset to use.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog. This project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v100b2-2024-06-21","title":"v1.0.0b2 (2024-06-21)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New context manager for typing-only imports, i.e. <code>type_importing()</code>.</li> </ul>"},{"location":"changelog/#v100b1-2024-06-21","title":"v1.0.0b1 (2024-06-21)","text":"<p>No significant changes.</p>"},{"location":"changelog/#v100b0-2024-06-17","title":"v1.0.0b0 (2024-06-17)","text":"<p>No significant changes.</p>"},{"location":"changelog/#v020-2024-06-14","title":"v0.2.0 (2024-06-14)","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Settled on stable interface: <code>lazy_importing</code>/<code>lazy_importing</code>, <code>lazy_importing_if</code>/<code>lazy_importing_if</code>.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Frame offset management of <code>__import__</code> replacement function.</li> </ul>"},{"location":"changelog/#v020b2-2024-06-14","title":"v0.2.0b2 (2024-06-14)","text":"<p>No significant changes.</p>"},{"location":"changelog/#v020b1-2024-06-14","title":"v0.2.0b1 (2024-06-14)","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Rewrote the entire library according to Jelle Zijlstra's 'special key' implementation. (#47)</li> </ul>"},{"location":"changelog/#v010-beta-2024-05-08","title":"v0.1.0-beta (2024-05-08)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Basic functionality and documentation.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at bartoszpiotrslawecki@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-slothy","title":"Contributing to slothy \ud83c\udf89","text":"<p>Contributions are very welcome. \ud83d\ude80</p> <p>There are many ways to contribute, ranging from writing tutorials and improving the documentation, to submitting bug reports and feature requests or writing code which can be incorporated into slothy.</p>"},{"location":"contributing/#report-bugs-and-request-features","title":"Report bugs and request features \ud83d\udc1b","text":"<p>Report these in the issue tracker. Relevant forms provide guidance on how to write a good bug report or feature request.</p>"},{"location":"contributing/#implement-new-features","title":"Implement new features \u2b50","text":"<p>Look here. Anything tagged with \"enhancement\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write documentation \ud83d\udcd6","text":"<p>The project could always use more documentation, whether as part of the official project docs,. If you're interested in helping out, check the docs/ folder in the repository.</p>"},{"location":"contributing/#share-your-feedback","title":"Share your feedback \ud83c\udf0d","text":"<p>The best way to send feedback is to file an issue in the issue tracker.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are     welcome! \u2728</li> </ul>"},{"location":"contributing/#get-started","title":"Get started! \ud83d\udd79\ufe0f","text":"<p>Ready to contribute? Here's a quick guide on how to set up slothy and make a change.</p> <p>Note</p> <p>If you use Windows, it is highly recommended to complete the installation in the way presented below through WSL2.</p> <ol> <li> <p>Fork the slothy repository on GitHub.</p> </li> <li> <p>Install Poetry.     Poetry is an amazing tool for managing dependencies &amp; virtual environments, building packages and publishing them.     You might use pipx to install it globally (recommended):</p> <pre><code>pipx install poetry\n</code></pre> <p><sub>If you encounter any problems, refer to the official documentation for the most up-to-date installation instructions.</sub></p> <p>Be sure to have Python 3.8 installed\u2014if you use pyenv, simply run:</p> <pre><code>pyenv install 3.8\n</code></pre> </li> <li> <p>Clone your fork locally and install dependencies.</p> <pre><code>git clone https://github.com/your-username/slothy path/to/slothy\ncd path/to/slothy\npoetry env use $(cat .python-version)\npoetry install\n</code></pre> <p>Next up, simply activate the virtual environment and install pre-commit hooks:</p> <pre><code>poetry shell\npre-commit install\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass all tests:</p> <pre><code>poe check\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add -A\ngit commit -m \"Short description of changes (50 chars max)\" -m \"Optional extended description\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"guidelines/","title":"Guidelines","text":"<p>slothy offers advanced use cases for highly aware Python developers.</p> <p>Tip</p> <p>Pick your weapons carefully. If lazy importing with slothy doesn't make your codebase significantly easier to maintain, then maybe it's a bad idea to use it.</p> <p>This document aims to present general DOs and DON'Ts to follow if using slothy. They gather opinions from the author(s) of slothy.</p> <p>Warning</p> <p>The rest of this document can be very technical sometimes. Check out the tutorial for a more beginner-friendly description of the intended uses of slothy.</p>"},{"location":"guidelines/#1-dont-use-slothy-without-a-reason","title":"1. Don't use slothy without a reason","text":"<p>Here are some obviously unnecessary uses of slothy:</p> Importing lazily to eagerly import right afterMixing lazy and eager imports unconditionally <p>Instead of</p> <pre><code>with lazy_importing():\n    import pandas as pd\n\n# In the line below, right under the lazy import, you import pandas eagerly.\ndf = pd.DataFrame()\n</code></pre> <p>You can just do</p> <pre><code>import pandas as pd\ndf = pd.DataFrame()\n</code></pre> <p>and that will be faster.</p> <p>This could make sense if you make a module that creates <code>df</code> lazily, e.g. when a function is called:</p> <pre><code>with lazy_importing():\n    import pandas as pd\n\ndef make_df() -&gt; pd.DataFrame:\n    return pd.DataFrame()\n\n# make_df() not called at the module level at all!\n# Someone else could import us and THEN call make_df(), perhaps\n# due to the instruction stack initiated in their\n# `if __name__ == \"__main__\"` section.\n</code></pre> <pre><code>import pandas as pd\n\nwith lazy_importing():\n    from pandas import DataFrame\n</code></pre> <p>You don't need slothy in this case. <code>pandas.DataFrame</code> was already imported by the first line.</p> <p>Just use</p> <pre><code>import pandas as pd\nfrom pandas import DataFrame\n</code></pre> <p>instead.</p> <p>Similarly, in</p> <pre><code>with lazy_importing():\n    # Declares a lazy import.\n    import pandas as pd  \n\n# Immediately destroys the entire point of declaring a lazy import.\nimport pandas as pd\n</code></pre> <p>you can just</p> <p><pre><code>import pandas as pd\n</code></pre> instead.</p> <p>Mixing eager and lazy imports might make sense if there's a logical branch of your code where the lazy import is not eventually performed.</p>"},{"location":"guidelines/#2-dont-rely-on-delayed-imports-programmatically","title":"2. Don't rely on delayed imports programmatically","text":"<p>While slothy changes the underlying import system behavior to delay imports, you should never rely on the side effects it brings.</p> <p>For example, if from <code>spam.py</code> you import a module <code>eggs.py</code> that is located in the same directory:</p> <pre><code># ./spam.py\n\nwith lazy_importing():\n    from .eggs import Ham\n</code></pre> <p>you should never rely on <code>from .eggs import Ham</code> not executing some code it otherwise would if it wasn't lazy. For example, don't base off on the fact that <code>Ham</code> is not present in <code>Ham.__base__.__subclasses__()</code> after that lazy import.</p> <p>In other words, stick to decoupling and give your separate modules autonomy. Never make decisions based on side effect mutations to the global state of your program.</p>"},{"location":"guidelines/#3-dont-prevent-eager-imports-in-libraries","title":"3. Don't prevent eager imports in libraries","text":"<p>Note</p> <p>You can ignore this rule if you need <code>type_importing()</code> in your library.</p> <p>As a general recommendation:</p> <ul> <li>Use <code>with lazy_importing()</code> in apps.</li> <li>Use <code>with lazy_importing(prevent_eager=False)</code> in libraries.</li> </ul> <p>Try to make libraries as much compatible with non-CPython implementations as possible. slothy, tailored for applications, raises a <code>RuntimeError</code> if it can't ensure imports aren't lazy inside a <code>with lazy_importing()</code> block.</p>"},{"location":"guidelines/#4-use-type_importing-for-type-checking-imports-that-may-eventually-be-needed-at-runtime","title":"4. Use <code>type_importing()</code> for type-checking imports that may eventually be needed at runtime","text":"<p>If you need slothy for delaying imports of typing-only items that might eventually be requested at runtime (for example by Pydantic), use a dedicated context manager <code>type_importing()</code>. That manager falls back to <code>typing.Any</code> (or other configured runtime-available type) when it cannot import the actual type-checking item.</p> <p>For instance: <pre><code>&gt;&gt;&gt; with type_importing():\n...     from _typeshed import StrPath\n...\n&gt;&gt;&gt; print(StrPath)\ntyping.Any\n</code></pre></p> <p>Warning</p> <p>If your type-checking imports aren't used at runtime, simply drop using <code>type_importing()</code> (or even entire slothy) at all. However, if you need to pick up type-checking items at runtime, use <code>type_importing()</code> consistently in the entire codebase to minimize the \"I'm confused\" factor (amongst other factors).</p>"},{"location":"guidelines/#5-dont-lazy-import-in-class-scopes","title":"5. Don't lazy-import in class scopes","text":"<p>This won't work: <pre><code>class Foo:\n    with lazy_importing():\n        from whatever import maybe_descriptor\n</code></pre></p> <p>The reason for this is that <code>Foo.maybe_descriptor</code> might potentially be a descriptor, which implies slothy would need to broker between its <code>__get__</code>, <code>__set__</code>, <code>__delete__</code> and even <code>__set_name__</code> which is already a reason to import it eagerly.</p> <p>You can imagine that <code>maybe_descriptor</code> can be</p> <pre><code># whatever.py\n\n@property\ndef maybe_descriptor(self) -&gt; None:\n    print(\"I'm here against all the linting rules!\")\n    return None\n\n@maybe_descriptor.setter\ndef maybe_descriptor(self, _value: object) -&gt; None:\n    print(\"What's up?\")\n</code></pre> <p>Even though this is legal in Python, slothy, similarly to mypy, doesn't support descriptors bound via imports.</p> <p>If you need to lazy-import inside classes, use a class-local property (or a custom descriptor):</p> <pre><code>with lazy_importing():\n    from whatever import anything\n\n\nclass BetterFoo:\n    @property\n    def descriptor(self) -&gt; Anything:\n        return anything  # this binds the item in globals() forever\n</code></pre> <p>or, even better:</p> <pre><code>class EvenBetterFoo:\n    @property\n    def descriptor(self) -&gt; ???:\n        from whatever import anything\n        return anything\n</code></pre> <p>or, even better than that, don't do such a thing at all.</p> <p>Note</p> <p>Opinion: Property getters should ideally not have any side effects. A kind reminder: <code>inspect.getmembers_static</code> was only added in 3.11!</p>"},{"location":"how_it_works/","title":"How It Works","text":"<p>slothy can feel like it's magic, but the trick is super simple.</p>"},{"location":"how_it_works/#it-all-started-with-a-dictionary","title":"It all started with a dictionary","text":"<p>Python scopes are essentially dictionaries. Most of the times they can be accessed via <code>locals()</code> and <code>globals()</code>.</p> Define a variable <code>foo</code>See <code>foo</code> in <code>locals()</code>See <code>foo</code> in <code>globals()</code> <pre><code>&gt;&gt;&gt; foo = 1\n</code></pre> <pre><code>&gt;&gt;&gt; foo = 1\n&gt;&gt;&gt; locals()\n{'__annotations__': {},\n'__builtins__': &lt;module 'builtins' (built-in)&gt;,\n'__doc__': None,\n'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;,\n'__name__': '__main__',\n'__package__': None,\n'__spec__': None,\n'foo': 1}\n</code></pre> <p>Note</p> <p>This includes a bunch of things Python automatically assigns to the module-level variables to work correctly. Unsurprisingly, they are dunders and we typically don't need to know they are there.</p> <pre><code>&gt;&gt;&gt; foo = 1\n&gt;&gt;&gt; locals()\n{'__annotations__': {},\n'__builtins__': &lt;module 'builtins' (built-in)&gt;,\n'__doc__': None,\n'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;,\n'__name__': '__main__',\n'__package__': None,\n'__spec__': None,\n'foo': 1}\n&gt;&gt;&gt; # In this case it's the same as locals(),\n&gt;&gt;&gt; # because we're at the module level.\n&gt;&gt;&gt; globals()\n{'__annotations__': {},\n'__builtins__': &lt;module 'builtins' (built-in)&gt;,\n'__doc__': None,\n'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;,\n'__name__': '__main__',\n'__package__': None,\n'__spec__': None,\n'foo': 1}\n</code></pre> <p>At the module level (outside any functions/classes), <code>locals()</code> and <code>globals()</code> are the same dictionary.</p> <p>We can reference a global variable from inside a module-level function, and that will first look up the <code>locals()</code> dictionary from there and then <code>globals()</code> without us having to do it manually:</p> Call a functionLook up <code>x</code>Resolve <code>x</code>Return <code>x</code> <p>Given the code below, we call our <code>func</code> first.</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x\n\nprint(func())\n</code></pre> <p>Once <code>func</code> is called, <code>x</code> is requested:</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x\n\nprint(func())\n</code></pre> <p>Python looks here (<code>locals()</code>):</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x\n\nprint(func())\n</code></pre> <p>Then here (<code>globals()</code>):</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x\n\nprint(func())\n</code></pre> <p>and... &gt;&gt;&gt;</p> <p>...finally sees it here, in <code>globals()</code>:</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x\n\nprint(func())\n</code></pre> <p>Now <code>x</code> can be returned.</p> <pre><code>x = \"whatever\"\n\ndef func():\n    return x  # found it!\n\nprint(func())  # outputs 'whatever'\n</code></pre> <p>But <code>globals()</code> isn't where the lookup ends: as you might have already noticed, we often use names that aren't inside <code>globals()</code> nor any subsequent <code>locals()</code>. That is, why does <code>globals</code> work in the first place?!</p> <pre><code>&gt;&gt;&gt; globals\n&lt;built-in function globals&gt;\n&gt;&gt;&gt; \"globals\" in globals()\nFalse\n&gt;&gt;&gt; # How on earth is that possible?\n</code></pre> <p>Well, there's another scope that they probably don't want you to know about. It's called the built-in scope and it correlates with the <code>builtins</code> module.</p> <p>What is interesting, those built-ins are typically mounted through the <code>__builtins__</code> variable that you could have noticed before:</p> <pre><code>&gt;&gt;&gt; foo = 1\n&gt;&gt;&gt; locals()\n{'__annotations__': {},\n'__builtins__': &lt;module 'builtins' (built-in)&gt;,\n'__doc__': None,\n'__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;,\n'__name__': '__main__',\n'__package__': None,\n'__spec__': None,\n'foo': 1}\n</code></pre> <p>In CPython, changing the value of <code>__builtins__</code> can change the actual built-in scope entirely for all subsequent frames, i.e. the entire call stack starting from the moment you override the <code>__builtins__</code> variable.</p> <p>This is what slothy initially relied on: it captured undefined names (since built-ins is the last scope checked) from a program and then looked it up in \"lazy import declarations\" to import them on demand.</p> <p>However, that didn't work outside CPython, because it's not in the standard.</p> <p>So, what slothy does instead is...</p>"},{"location":"how_it_works/#intercepting-dictionary-access","title":"Intercepting dictionary access","text":"<p>From the documentation on mappings:</p> <p>A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. (...) A dictionary\u2019s keys are almost arbitrary values. Values that are not hashable (...) may not be used as keys. Values that compare equal (such as <code>1</code>, <code>1.0</code>, and <code>True</code>) can be used interchangeably to index the same dictionary entry.</p> <p>From the documentation on hashable objects:</p> <p>An object is hashable if it has a hash value which never changes during its lifetime (it needs a <code>__hash__()</code> method), and can be compared to other objects (it needs an <code>__eq__()</code> method). Hashable objects which compare equal must have the same hash value.</p> <p>Which makes sense with regard to the previous quote:</p> <pre><code>&gt;&gt;&gt; hash(1)\n1\n&gt;&gt;&gt; 1 == 1.0\nTrue\n&gt;&gt;&gt; hash(1.0)\n1\n&gt;&gt;&gt; 1 == True\nTrue\n&gt;&gt;&gt; hash(True)\n1\n</code></pre> <p>Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.</p> <p>Knowing that, let's see what happens if we try to insert a custom key to a dictionary.The new, \"special\" key will:</p> <ul> <li>log every <code>__hash__</code> and <code>__eq__</code> call,</li> <li>be equal to every string of value <code>\"special\"</code>.</li> </ul> <pre><code>&gt;&gt;&gt; class SpecialKey:\n...     def __eq__(self, other):\n...         print(\"__eq__ called\")\n...         return \"special\" == other\n...     def __hash__(self):\n...         print(\"__hash__ called\")\n...         return hash(\"special\")\n</code></pre> <p>And we are good to go!</p> Create a dictionaryInsert the special keyCheck against invalid keyCheck against <code>\"special\"</code>Check against a colliding key <p>Let's create the dictionary we will experiment on.</p> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n</code></pre> <p>Let's insert the key.</p> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Insert out special key that equals \"special\".\n&gt;&gt;&gt; d[SpecialKey()] = 1\n__hash__ called\n</code></pre> <p>Notice that <code>__hash__</code> was called.</p> <p>Just to make sure, we will try to get a key that can't exist in that dictionary.</p> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Insert out special key that equals \"special\".\n&gt;&gt;&gt; d[SpecialKey()] = 1\n__hash__ called\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Try to get an inexisting key.\n&gt;&gt;&gt; d[object()]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: &lt;object object at 0xc0ffee04bee4&gt;\n</code></pre> <p>The reason for the dictionary to know this is an invalid key is that there is no value under a key with the same hash as that of the requested <code>object()</code>.</p> <p>Hash-based lookup is what makes dictionaries (and hash tables in general) so fast.</p> <p>We intended the special key to be interoperable with a string <code>\"special\"</code>. Let's try it then.</p> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Insert out special key that equals \"special\".\n&gt;&gt;&gt; d[SpecialKey()] = 1\n__hash__ called\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Try to get an inexisting key.\n&gt;&gt;&gt; d[object()]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: &lt;object object at 0xc0ffee04bee4&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; d[\"special\"]\n__eq__ called\n1\n</code></pre> <p>That works! Notice that <code>__eq__</code> was called.</p> <p>You might ask: why? If hashable objects which compare equal must have the same hash value, why would we have to additionally check their equality? &gt;&gt;&gt;</p> <p>Well, imagine an object that very randomly has the same hash as the string <code>\"special\"</code>.</p> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Insert out special key that equals \"special\".\n&gt;&gt;&gt; d[SpecialKey()] = 1\n__hash__ called\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Try to get an inexisting key.\n&gt;&gt;&gt; d[object()]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: &lt;object object at 0xc0ffee04bee4&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; d[\"special\"]\n__eq__ called\n1\n&gt;&gt;&gt;\n&gt;&gt;&gt; class RandomlyCollidingKey:\n...     colliding = True\n...     def __hash__(self):\n...         return hash(\"special\")\n...     def __eq__(self, other):\n...         # All RandomlyCollidingKey objects have this attribute\n...         # set to True.\n...         return bool(getattr(other, \"colliding\", None))\n...\n&gt;&gt;&gt; d[RandomlyCollidingKey()]\n__eq__ called\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: &lt;__main__.RandomlyCollidingKey object at 0xfeeddeadbeef&gt;\n&gt;&gt;&gt; d[RandomlyCollidingKey()] = 2\n__eq__ called\n&gt;&gt;&gt; d[\"special\"]\n__eq__ called\n1\n&gt;&gt;&gt; d[RandomlyCollidingKey()]\n__eq__ called\n2\n</code></pre> <p>What <code>__eq__</code> ultimately gives us is the possibility of maintaining distinct keys with colliding hashes in the same dictionary.</p> <p>In conclusion, Python dictionaries let us map objects with possibly colliding hashes to values and retrieve them quickly, making sure we get (and set) what we intend.</p> <p>Since arbitrary objects participate in the process of dictionary key resolution, slothy does its magic by modifying the first step to operate on a slightly different dictionary:</p> Our experimentslothy <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = {}\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a dictionary.\n&gt;&gt;&gt; d = locals()\n</code></pre> <p>You get the point?</p> <p>slothy essentially uses the \"special key\" idea and implements behavior that dynamically imports items on their first actual lookup inside your <code>locals()</code>.</p> <p>These keys are created on every import inside slothy context managers that temporarily patch <code>__import__</code> in your built-in scope: the function without which the <code>import</code> statement wouldn't work.</p> <p>This was How It Works. Congrats for making it this far! \ud83c\udf89</p>"},{"location":"installation/","title":"Installation","text":"<p>slothy is available on PyPI and is thus installable by most Python package managers.</p>"},{"location":"installation/#examples","title":"Examples","text":"<pre><code>pip install slothy\nuv pip install slothy\npoetry add slothy\nrye add slothy\npdm add slothy\n# Etc. This list isn't exhaustive.\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>Warning</p> <p>Work in progress.</p>"},{"location":"why_slothy/","title":"Why <i>slothy</i>?","text":"<p>Warning</p> <p>Work in progress.</p>"}]}